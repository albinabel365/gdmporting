var gcm =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.launcher = exports.GCMLauncher = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Validate = __webpack_require__(1);

var _UrlUtil = __webpack_require__(2);

__webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GCMLauncher = exports.GCMLauncher = function () {
  function GCMLauncher() {
    _classCallCheck(this, GCMLauncher);

    this.gcmWindow = null;
    this.gcmOrigin = null;
    this.ogsParams = null;
    this.supressGameSizeAdjust = true;
    this.stringEndsWithPolyfill();
  }

  _createClass(GCMLauncher, [{
    key: 'init',
    value: function init() {

      var gameUrl = this.getUrlParam('gameUrl');

      addEventListener("message", this.receiveMessage.bind(this), false);

      var gameIFrame = document.getElementById('gameIFrame');
      var footerIFrame = document.getElementById('footerIFrame');
      // Only desktop games have gameUrl passed as a urlParam
      if (gameUrl != undefined && gameUrl != null) {
        // don't have ogsParams yet, and we know this has to be desktop
        this.extractOGSParams(window.location.search, true);

        var operator_id = this.ogsParams["operatorid"];
        var device = this.ogsParams["device"];

        // Load gameUrl in gameIFrame
        gameIFrame.src = gameUrl;

        // If footer is enabled, load footer in footerIFrame
        if (this.isFooterEnabled(operator_id, device)) {
          this.loadFooter(operator_id, device);
        } else {
          footerIFrame.style.height = "0%";
          footerIFrame.style.width = "0%";
        }
      } else {
        gameIFrame.style.display = "none";
        footerIFrame.style.display = "none";
        document.body.style.background = "transparent";
      }
    }
  }, {
    key: 'loadOperatorPostMsgLibrary',
    value: function loadOperatorPostMsgLibrary() {

      // always clear this value, so malicious values (inserted in to URL)
      // are not picked up in gcmCore
      this.ogsParams["operatorPostMessageLibraryUrl"] = "";

      var operatorPostMessageLibraryUrl = GCMConfig.getOperatorSpecificProperty("operatorPostMsgLibrary", this.ogsParams["operatorid"], this.ogsParams["device"]);

      if (operatorPostMessageLibraryUrl != undefined) {
        this.ogsParams["operatorPostMessageLibraryUrl"] = operatorPostMessageLibraryUrl;
        var p = this.addServiceScript(operatorPostMessageLibraryUrl);
        p.then(function (val) {
          return console.log("Operator post msg library script loaded");
        }, function (err) {
          throw new Error("Failed to load Operator post msg library: ", err);
        });
      }
    }
  }, {
    key: 'extractOGSParams',
    value: function extractOGSParams(urlString, isDesktop) {
      var searchParams = _UrlUtil.UrlUtil.getAllParams(urlString, isDesktop);
      var requestParams = {};
      searchParams.forEach(function (element) {
        if ("gameUrl" != name) {
          requestParams[element[0]] = decodeURIComponent(element[1]);
        }
      });
      this.ogsParams = requestParams;
    }
  }, {
    key: 'getUrlParam',
    value: function getUrlParam(name) {
      if (name = new RegExp('[?&]' + encodeURIComponent(name) + '=([^&]*)').exec(window.location.search)) return decodeURIComponent(name[1]);
    }
  }, {
    key: 'isKnownGameProvider',
    value: function isKnownGameProvider(hostName) {
      return GCMConfig.gameProviderHostNameList.some(function (element) {
        return hostName.endsWith(element);
      });
    }
  }, {
    key: 'receiveMessage',
    value: function receiveMessage(event) {

      if (this.isKnownGameProvider(event.origin)) {
        try {
          var data = JSON.parse(event.data);
          var method = data["action"];
          var methodParams = data["params"];

          if (_Validate.Validate.isValidGCMLauncherMethod(method)) {
            this[method](event, methodParams);
          } else {
            console.log("GCM Launcher: No permission to execute method " + method);
          }
        } catch (e) {}
      } else {
        console.log("Discarding post message from un-registered game provider: " + event.origin);
      }
    }
  }, {
    key: 'isFooterEnabled',
    value: function isFooterEnabled(operator_id, device) {
      return GCMConfig.getOperatorSpecificProperty("footerEnabled", operator_id, device) === true;
    }
  }, {
    key: 'getFooterDetails',
    value: function getFooterDetails(operator_id, device) {
      return {
        "footerUrl": GCMConfig.getOperatorSpecificProperty("footerUrl", operator_id, device),
        "footerSize": GCMConfig.getOperatorSpecificProperty("footerSize", operator_id, device)
      };
    }
  }, {
    key: 'loadFooter',
    value: function loadFooter(operator_id, device) {
      var footerDetails = this.getFooterDetails(operator_id, device);
      var footerIFrame = document.getElementById('footerIFrame');
      footerIFrame.src = footerDetails["footerUrl"];
      footerIFrame.style.height = footerDetails["footerSize"]["height"];
      footerIFrame.style.width = footerDetails["footerSize"]["width"];
    }

    // This method as called as part of mobile game launch wherein GCM loads launcher.html in an iFrame
    // and calls this method as part of onLoad event for launcher.html.

  }, {
    key: 'launcherLoaded',
    value: function launcherLoaded(event, params) {

      this.extractOGSParams(params['gameUrl'], false);
      this.loadCommonUI(event, params);
      var commonUIIFrame = document.getElementById('commonUIIFrame');
      commonUIIFrame.style.height = "100%";
      commonUIIFrame.style.width = "100%";
    }
  }, {
    key: 'loadCommonUI',
    value: function loadCommonUI(event, params) {
      var _this = this;

      var gameName = this.ogsParams["gameid"];

      // If gameName is supplied to GCM by Game, then it will be included when GCM calls this method
      if (params && params['gameName'] && params['gameName'] != "") {
        gameName = params['gameName'];
      }

      this.ogsParams["gameName"] = gameName;

      // Set launcher.html title to gameName
      document.title = gameName;

      var cuiParams = {
        "operatorId": this.ogsParams["operatorid"],
        "currency": this.ogsParams["currency"],
        "device": this.ogsParams["device"],
        "extGameId": this.ogsParams["gameid"],
        "gameName": this.ogsParams["gameName"],
        "playMode": this.ogsParams["mode"],
        "sessionId": this.ogsParams["sessionid"],
        "loggedIn": this.ogsParams["sessionid"] != null,
        "lang": this.ogsParams["lang"]
      };

      // Add optional OGS params if available
      if (this.ogsParams["realitycheck_uk_history"]) {
        cuiParams["realitycheck_uk_history"] = this.ogsParams["realitycheck_uk_history"];
      }
      if (this.ogsParams["realitycheck_uk_elapsed"]) {
        cuiParams["realitycheck_uk_elapsed"] = this.ogsParams["realitycheck_uk_elapsed"];
      }
      if (this.ogsParams["realitycheck_uk_proceed"]) {
        cuiParams["realitycheck_uk_proceed"] = this.ogsParams["realitycheck_uk_proceed"];
      }
      if (this.ogsParams["realitycheck_uk_exit"]) {
        cuiParams["realitycheck_uk_exit"] = this.ogsParams["realitycheck_uk_exit"];
      }
      if (this.ogsParams["lobbyurl"]) {
        cuiParams["lobbyurl"] = this.ogsParams["lobbyurl"];
      }

      // CONDENSE LOOKING FOR AND ASSIGNING OPTIONAL PARAMETERS
      var optionalOGSParams = ["responsiblegaming_url", "elapsedtime", "selfassessment_url", "depositlimit_url", "selfexclusion_url"];

      optionalOGSParams.map(function (param) {
        if (_this.ogsParams[param]) cuiParams[param] = _this.ogsParams[param];
      });
      // END ASSIGN OPTIONAL PARAMETERS

      var device = this.ogsParams["device"];
      var operator_id = this.ogsParams["operatorid"];

      if (this.isCMAEnabled()) {
        // Get hostname from supplied bridgeScriptUrl
        var matches = this.ogsParams["bridgeScriptUrl"].match(/^http?\:\/\/(?:www\.)?([^\/?#]+)(?:[\/?#]|$)/i);
        var hostName = matches && matches[1];
        // Use hostname to find the cma script url that needs to be loaded from configuration file.
        this.ogsParams["cmaScriptUrl"] = GCMConfig.getCMAScriptUrl(hostName, operator_id, device);
        this.ogsParams["bridgeScriptUrl"] = "";
      }

      // Add optional parameters passed from Game
      if (params) {
        if (params['cuiPosition']) {
          cuiParams['cuiPosition'] = params['cuiPosition'];
        }

        if (params['gameName']) {
          cuiParams['gameName'] = params['gameName'];
        }
      }

      // look-up CUI URL based on operator_id and device parameters
      //Append gcmVersion as urlParam so that commonUI can decide whether it is GCMV4 or GCMV3 integration
      var commonUIUrlString = GCMConfig.getOperatorSpecificProperty("commonUIUrl", operator_id, device) + "?gcmVersion=v4";

      var commonUIUrl = new URL(commonUIUrlString);

      // Configure gcm
      this.gcmWindow = event.source;
      this.gcmOrigin = event.origin;
      this.configureGCM(commonUIUrl.hostname);

      // Load commonUI on commonUIIframe and send 'init' postMessage
      this.loadCommonUIIframe(commonUIUrl, cuiParams, this.gcmOrigin);
    }

    // Method to retrieve OGS params

  }, {
    key: 'getOGSParams',
    value: function getOGSParams(event, params) {

      var singlePostMsgArg = false;
      var messageObject = {};

      if (params != undefined) {
        singlePostMsgArg = params["singlePostMsgArg"];
      }

      if (singlePostMsgArg) {
        // send single param as arg (from gcmCore) i.e. gcmCore.setOGSParams()
        // expects single param, but postMessageEventListener splits args
        messageObject["ogsParams"] = this.ogsParams;
      } else {
        // send split params for each ogsParam arg (from index_gcm4.html.j2)
        messageObject = this.ogsParams;
      }

      var message = this.createPostMessage("setOGSParams", messageObject);
      event.source.postMessage(message, event.origin);
    }
  }, {
    key: 'configureGCM',
    value: function configureGCM(commonUIOrigin) {

      //Desktop & Mobile have both called extractOGSParams() at this point
      this.loadOperatorPostMsgLibrary();

      var methodParams = {};
      methodParams["commonUIOrigin"] = commonUIOrigin;
      methodParams["ogsParams"] = this.ogsParams;
      methodParams["gcmConfiguration"] = GCMConfig.getGCMServiceConfiguration();
      methodParams["gsConfiguration"] = GCMConfig.getOperatorSpecificProperty("gamesparks", this.ogsParams.operatorid, "default");
      methodParams["jqConfiguration"] = GCMConfig.getOperatorSpecificProperty("jackpotQuery", this.ogsParams.operatorid, "default");
      //Create post message
      var message = this.createPostMessage("configure", methodParams);

      this.gcmWindow.postMessage(message, this.gcmOrigin);
    }
  }, {
    key: 'loadCommonUIIframe',
    value: function loadCommonUIIframe(commonUIUrl, cuiParams, gcmOrigin) {
      var ifrm_ = document.getElementById("commonUIIFrame");
      ifrm_.onload = function () {
        var messageObject = {};
        messageObject["action"] = "init";
        messageObject["gcmHostName"] = gcmOrigin;
        messageObject["cuiParams"] = cuiParams;
        var message = JSON.stringify(messageObject);
        ifrm_.contentWindow.postMessage(message, commonUIUrl.origin);
      };
      ifrm_.src = commonUIUrl.href;

      if (cuiParams["device"] == "desktop") {
        // for Mobile we add this listener in gcmCore as its inside root HTML DOM
        addEventListener('resize', this.launcherResized.bind(this), false);
      }
    }
  }, {
    key: 'commonUIReady',
    value: function commonUIReady(event, methodParams) {
      var cuiIFrame = document.getElementById("commonUIIFrame");
      cuiIFrame.style.display = "block";
    }
  }, {
    key: 'gameRevealed',
    value: function gameRevealed(event, methodParams) {
      if (this.ogsParams["device"] == "mobile") {
        var cuiIFrame = document.getElementById("commonUIIFrame");
        cuiIFrame.style.height = "100%";
        cuiIFrame.style.display = "inline"; // forced for IOS issue OGS-2620
      }
      this.supressGameSizeAdjust = false;
      this.launcherResized();
    }
  }, {
    key: 'reload',
    value: function reload(event, methodParams) {
      if (this.isHostedInIFrame()) {

        window.parent.postMessage(this.buildReloadRedirectPostMessage('reload'), '*');
      }

      window.location.reload();
    }
  }, {
    key: 'redirect',
    value: function redirect(event, methodParams) {

      var redirectUrl = methodParams[0];
      if (this.isHostedInIFrame()) {
        window.parent.postMessage(this.buildReloadRedirectPostMessage('redirect', redirectUrl), '*');
      }

      if (redirectUrl) {
        window.location.replace(redirectUrl);
      }
    }
  }, {
    key: 'isHostedInIFrame',
    value: function isHostedInIFrame() {
      return self.window !== top.window;
    }
  }, {
    key: 'buildReloadRedirectPostMessage',
    value: function buildReloadRedirectPostMessage(type, url) {
      var redirectURL = url || '';
      var message = { action: type, url: redirectURL };

      return JSON.stringify(message);
    }

    /**
    * This function is called by native browser 'resize' event.
    * It sends post msg to gcmCore, which then sends on to CUI and
    * game (if it implements the game resize API)
    */

  }, {
    key: 'launcherResized',
    value: function launcherResized() {
      var message = this.createPostMessage("launcherResized", [window.innerWidth, window.innerHeight]);
      this.gcmWindow.postMessage(message, this.gcmOrigin);
    }

    /**
    * This API can be called by GCM when common UI asks GCM to modify its height and width.
    * @public
    * @param {Object} event  Post message event object
    * @param {Object} methodParams commonUIResize params passed from commonUI
    * methodParams[0]: height new height of iframe.
    * methodParams[1] width (Optional) The new width of iframe, same format as height.
    * methodParams[2] offsetX Gap between top/bottom and start of the iframe.
    * methodParams[3] offsetY Gap between sides and start of the iframe.
    * methodParams[4] reAdjust Defaults to true. Only used for desktop games where
                      we need to re-adjust gameIframe based on commonUI size.
    */

  }, {
    key: 'commonUIResize',
    value: function commonUIResize(event, methodParams) {
      var height = methodParams[0];
      var width = methodParams[1];
      var offsetX = methodParams[2];
      var offsetY = methodParams[3];

      // Desktop games: Re-adjusting game iframe is not done when explicitly told by commonUI
      var reAdjust = true;
      if (methodParams[4] === false || methodParams[4] === 0) {
        reAdjust = false;
      }

      var commonUIIFrame = document.getElementById('commonUIIFrame');
      window.scrollTo(0, 1);

      if (offsetX && offsetY) {
        commonUIIFrame.style.height = height;
        commonUIIFrame.style.width = width;
        commonUIIFrame.style.left = offsetX;
        commonUIIFrame.style.top = offsetY;
        commonUIIFrame.style.marginLeft = 0;
      } else {
        if (height) {
          commonUIIFrame.style.height = height;
        }
        if (width) {
          commonUIIFrame.style.width = width;
          var currentWidth = commonUIIFrame.offsetWidth;
          commonUIIFrame.style.left = '50%';
          commonUIIFrame.style.marginLeft = -currentWidth / 2 + 'px';
        }
      }

      if (this.ogsParams["device"] == "desktop" && reAdjust && !this.supressGameSizeAdjust) {
        this.reAdjustGameIFrame(height);
      }
    }

    /**
    * Method to adjust gameIframe when commonUIIFrame changes.
    * Only needed for desktop games where commonUI has fixed portion of the screen.
    */

  }, {
    key: 'reAdjustGameIFrame',
    value: function reAdjustGameIFrame(commonUIHeight) {
      var gameIFrame = document.getElementById('gameIFrame');
      gameIFrame.style.top = commonUIHeight;
      var footerHeight = document.getElementById('footerIFrame').style.height;

      var gameHeight = "calc(100% - " + commonUIHeight + " - " + footerHeight + ")";
      gameIFrame.style.height = gameHeight;
    }

    /**
     * Checks that the input is a valid css height spec.
     * valid units: %,in,cm,mm,em,ex,pt,pc,px
     *
     * @param {string} value the number to validate.
     * @return {boolean} the result of the check.
     */

  }, {
    key: 'isHeight',
    value: function isHeight(value) {
      var height = /^\d+(\.\d+)?(%|in|cm|mm|em|ex|pt|pc|px)/;
      return height.test(value);
    }

    /**
     * Checks if CMA handling needs to be done.
     * Currently presence of bridgeScriptUrl indicates CMA being enabled.
     * @return {boolean} the result of the check.
     */

  }, {
    key: 'isCMAEnabled',
    value: function isCMAEnabled() {
      return this.ogsParams["bridgeScriptUrl"] && this.ogsParams["bridgeScriptUrl"] != "";
    }
  }, {
    key: 'createPostMessage',
    value: function createPostMessage(methodName, methodParams) {
      var messageObject = { 'action': methodName, 'params': methodParams };
      return JSON.stringify(messageObject);
    }

    /**
     * Polyfill for IE browsers that do not support
     * String.prototype.endsWith method
     */

  }, {
    key: 'stringEndsWithPolyfill',
    value: function stringEndsWithPolyfill() {
      if (!String.prototype.endsWith) {
        String.prototype.endsWith = function (search, this_len) {
          if (this_len === undefined || this_len > this.length) {
            this_len = this.length;
          }
          return this.substring(this_len - search.length, this_len) === search;
        };
      }
    }

    /**
     * Helper method to load a supplied javascript url on the current window
     * @private
     * @param {string} scriptUrl
     */

  }, {
    key: 'addServiceScript',
    value: function addServiceScript(scriptUrl) {
      return new Promise(function (resolve, reject) {
        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = scriptUrl;
        script.addEventListener('load', function () {
          return resolve(script);
        }, false);
        script.addEventListener('error', function () {
          return reject(script);
        }, false);
        document.body.appendChild(script);
      });
    }
  }]);

  return GCMLauncher;
}();

var launcher = exports.launcher = new GCMLauncher();

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Validation functions for input validation
 */

var gcmLauncherPostMessageMethods = ['getOGSParams', 'loadCommonUI', 'commonUIReady', 'commonUIResize', 'gameRevealed', 'reload', 'redirect', 'showCommonUI', 'hideCommonUI', 'launcherLoaded'];

var gcmPostMessageMethods = ['configure', 'launcherResized', 'registerService', 'commonUIReady', 'commonUIResize', 'gameRevealed', 'optionHasChanged', 'resume', 'reload', 'redirect', 'showCommonUI', 'hideCommonUI', 'isGameIdle', 'balancesUpdate', 'setOGSParams'];

var commonUIPostMessageMethods = ['stakeUpdate', 'paidUpdate', 'balancesUpdate', 'loadProgressUpdate', 'gameReady', 'configReady', 'gameAnimationStart', 'gameAnimationComplete', 'gameIdle', 'handleError', 'handleSessionDurationUpdate', 'regOption', 'optionHasChanged', 'handleSessionStats', 'gameResized', 'gameHasLoadingScreen', 'handleMessageTrigger', 'handleGSTrigger', 'handleFreeRoundsAward', 'handleFreeRoundsInProgress', 'handleFreeRoundsUpdate', 'pollJackpots'];

var Validate = exports.Validate = function () {
    function Validate() {
        _classCallCheck(this, Validate);
    }

    _createClass(Validate, null, [{
        key: 'isBalances',


        /**
         * Check the a balances object is in the correct format
         * @param {Object} balances object.
         * @param {string} fundMode determines whether game is use any other fund mode than cash or freebet.
         * @return {boolean} the result of the check.
         */
        value: function isBalances(balances, fundMode) {
            //return false if it's null object
            if (!balances) return false;

            //balances must include at least a CASH balance
            if (_typeof(balances['CASH']) !== 'object') {
                return false;
            }

            for (var type in balances) {
                if (typeof balances[type]['amount'] !== 'number') {
                    return false;
                }
            }
            if (fundMode && 'FREESPIN' == fundMode) {
                if (_typeof(balances['FREESPIN']) !== 'object') return false;
            } else {
                if (_typeof(balances['FREESPIN']) == 'object') return false;
            }
            return true;
        }
    }, {
        key: 'isErrorInfo',


        /**
         * Check that a errorInfo contains the correct properties.
         * @param {Object} errorInfo an errorInfo object.
         * @return {boolean} the result of the check.
         */
        value: function isErrorInfo(errorInfo) {
            if (!errorInfo) {
                return false;
            }

            return !(typeof errorInfo['errorCode'] == 'undefined' || typeof errorInfo['errorMessage'] == 'undefined');
        }
    }, {
        key: 'isValidCurrencyOps',


        /**
         * Check the a accountInfo ccy params are in the correct format
         * CCY code can be empty.
         *
         * @param {Object} accountInfo object.
         * @return {boolean} the result of the check.
         */
        value: function isValidCurrencyOps(accountInfo) {

            if (!accountInfo) return false;

            var patternSeparator = /^[\D]$/;
            var patternCCY = /^[\D]*$/;

            return patternSeparator.test(accountInfo['ccy_thousand_separator']) && patternSeparator.test(accountInfo['ccy_decimal_separator']) && patternCCY.test(accountInfo['ccy_code']);
        }
    }, {
        key: 'isNumericValue',


        /**
         * Check the input is numeric
         * @param {number} value the number to validate.
         * @return {boolean} the result of the check.
         */
        value: function isNumericValue(value) {
            return typeof value == 'number' && !isNaN(parseFloat(value)) && isFinite(value);
        }
    }, {
        key: 'isIntegerValue',


        /**
         *
         * @param {number} value the number to validate.
         * @return {boolean} the result of the check.
         */
        value: function isIntegerValue(value) {

            return typeof value == 'number' && !isNaN(parseInt(value, 10)) && parseInt(value, 10) == value && isFinite(value);
        }
    }, {
        key: 'isPercentValue',


        /**
         * @param {number} value the percentage value to validate.
         * @return {boolean} the result of the check.
         */
        value: function isPercentValue(value) {

            if (this.isNumericValue(value)) {
                return parseFloat(value) <= 100 && !(parseFloat(value) < 0);
            }
            return false;
        }
    }, {
        key: 'isHeight',


        /**
         * Checks that the input is a valid css height spec.
         * valid units: %,in,cm,mm,em,ex,pt,pc,px
         *
         * @param {string} value the number to validate.
         * @return {boolean} the result of the check.
         */
        value: function isHeight(value) {
            var height = /^\d+(\.\d+)?(%|in|cm|mm|em|ex|pt|pc|px)/;
            return height.test(value);
        }
    }, {
        key: 'isAlphaNumeric',


        /**
         * Checks that this is a string of non zero length with only letters and numbers
         * @param {string} str the value to validate.
         * @return {boolean} the result of the check.
         */
        value: function isAlphaNumeric(str) {
            if (typeof str != 'string') return false;

            return (/^[a-zA-Z0-9]+$/.test(str)
            );
        }
    }, {
        key: 'isValidGameName',


        /**
         * Checks that string is valid game name
         * @param {string} str the value to validate.
         * @return {boolean} the result of the check.
         */
        value: function isValidGameName(str) {
            if (typeof str != 'string') return false;

            return (/^[a-zA-Z0-9\-_]+$/.test(str)
            );
        }
    }, {
        key: 'isValidLanguage',


        /**
         * Checks that string is valid language
         * language can be just a 
         * @param {string} str the value to validate.
         * @return {boolean} the result of the check.
         */
        value: function isValidLanguage(str) {
            if (typeof str != 'string') return false;

            var lang_array = str.split("-");
            var patternLanguage = /^[a-z]{2}$/;

            if (lang_array.length === 1) return patternLanguage.test(lang_array[0]);

            if (lang_array.length === 2) {
                var patternCountry = /^[A-Z]{2}$/;
                return patternLanguage.test(lang_array[0]) && patternCountry.test(lang_array[1]);
            }

            // otherwise
            return false;
        }
    }, {
        key: 'isSingleLetter',


        /**
         * Checks the string is a single letter. Useful for checking channels
         * @param {string} str the value to validate.
         * @return {boolean} the result of the check.
         */
        value: function isSingleLetter(str) {
            return (/^[a-zA-Z]$/.test(str)
            );
        }
    }, {
        key: 'isSingleDigit',


        /**
         * Checks the string is a single digit. Useful for checking channels
         * @param {string} str the value to validate.
         * @return {boolean} the result of the check.
         */
        value: function isSingleDigit(str) {
            return (/^[0-9]$/.test(str)
            );
        }
    }, {
        key: 'isEnumOption',


        /**
         * @param {Object} optionTypes enum of valid options.
         * @param {string} optionType for validation.
         * @return {boolean} the result of the check.
         */
        value: function isEnumOption(optionTypes, optionType) {

            var found = false;
            for (var key in optionTypes) {
                if (optionType === optionTypes[key]) {
                    found = true;
                    break;
                }
            }
            return found;
        }
    }, {
        key: 'isFunction',


        /**
         * @param {Object} callBack function passed through.
         * @return {boolean} the result.
         */
        value: function isFunction(callBack) {
            return typeof callBack === 'function';
        }
    }, {
        key: 'isDefinedAndNotNull',


        /**
         * Helper function to check if a variable is defined, not empty and not null.
         * @param variable
         * @return {boolean} the result.
         */
        value: function isDefinedAndNotNull(inputVariable) {
            if (typeof inputVariable !== "undefined" && inputVariable !== null && inputVariable != "") return true;else return false;
        }
    }, {
        key: 'isElement',


        /**
         * @param {Element} elem value to be validated.
         * @return {boolean} Is the object a DOM element.
         */
        value: function isElement(elem) {
            return Boolean(elem && typeof elem.appendChild === 'function');
        }
    }, {
        key: 'isValidCommonUIMethod',


        /**
         * @param {String} methodName method to validate
         * @return {boolean} Returns true if the method supplied is a valid commonUI method
         */
        value: function isValidCommonUIMethod(methodName) {
            return commonUIPostMessageMethods.indexOf(methodName) != -1;
        }
    }, {
        key: 'isValidGCMMethod',


        /**
         * @param {String} methodName method to validate
         * @return {boolean} Returns true if the method supplied is a valid GCM method
         */
        value: function isValidGCMMethod(methodName) {
            return gcmPostMessageMethods.indexOf(methodName) != -1;
        }
    }, {
        key: 'isValidGCMLauncherMethod',


        /**
         * @param {String} methodName method to validate
         * @return {boolean} Returns true if the method supplied is a valid GCM Launcher method
         */
        value: function isValidGCMLauncherMethod(methodName) {
            return gcmLauncherPostMessageMethods.indexOf(methodName) != -1;
        }
    }, {
        key: 'isValidBoolean',


        /**
         * @param {boolean} boolean input
         * @return {boolean} Returns true if the variable supplied is a valid boolean
         */
        value: function isValidBoolean(booleanVariable) {
            return typeof booleanVariable === "boolean";
        }
    }]);

    return Validate;
}();

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * UrlUtil (<b>com.openbet.gcm.urlutil</b>) provides utility
 * functions for manipulating url string and request parameters.
 *
 * Using this util game/commonUI developer can get/add/update url request parameters.
 * This functionality is exposed in com.openbet.gcm.urlutil.
 *
 *
 * @author xliu
 * @namespace
 */

var UrlUtil = exports.UrlUtil = function () {
  function UrlUtil() {
    _classCallCheck(this, UrlUtil);
  }

  _createClass(UrlUtil, null, [{
    key: 'addParametersToUrl',


    /**
    * Gets a parameter value from the passed in URL There are other ways to
    * implement this that could be quicker This solution is used here because it is
    * easy to follow
    * @param {string} url url to add params.
    * @param {Object} params object representing params to be added.
    * @return {string} encoded string url.
    */
    value: function addParametersToUrl(url, params) {

      for (var p in params) {
        var param = p + '=' + encodeURIComponent(params[p]);

        var sep = '&';
        if (url.indexOf('?') < 0) {
          sep = '?';
        } else {
          var lastChar = url.slice(-1);
          if (lastChar == '&') sep = '';
          if (lastChar == '?') sep = '';
        }
        url += sep + param;
      }
      return url;
    }
  }, {
    key: 'getSearchParameterByName',


    /**
    * Gets a parameter value from the passed in URL There are other ways to
    * implement this that could be quicker This solution is used here because it is
    * easy to follow
    * @param {string} name request parameter name.
    * @param {string} search (this can be obtained from window.location.search).
    * @return {?string} request parameter value.
    */
    value: function getSearchParameterByName(name, search) {

      if (typeof name !== 'string') {
        throw new Error('gcmBridge.getSearchParameterByName: Invalid argument name - not a string');
      }
      if (typeof search !== 'string') {
        throw new Error('gcmBridge.getSearchParameterByName: Invalid argument search - not a string');
      }

      /** @type {RegExp} */
      var pattern;
      /** @type {Array} */
      var match;
      pattern = new RegExp('[?&]' + name + '=([^&]*)');
      match = pattern.exec(search);

      if (match && match.length > 1) return decodeURIComponent(match[1].replace(/\+/g, ' '));else return null;
    }
  }, {
    key: 'updateSearchParameterByName',


    /**
    * Update a parameter value from the passed in URL. <br>
    * @param {string} name request parameter name.
    * @param {string} newValue thenew value for request parameter.
    * @param {string} url (this can be obtained from window.location.href).
    * @return {?string} The new url with updated request parameter.
    */
    value: function updateSearchParameterByName(name, newValue, url) {
      var originalValue = UrlUtil.getSearchParameterByName(name, url);
      var newURL = url;
      if (originalValue) {
        newURL = url.replace(name + '=' + originalValue, name + '=' + newValue);
      }
      return newURL;
    }
  }, {
    key: 'getGCMParams',


    /**
     * This function returns a object of gcm params. <br>
     * For getting the gcm parameter's values, first gcmParams parameter's value will be
     * fetched from URL using UrlUtil.getSearchParameterByName function. The example of gcmParams variable
     * is detailed below : <br>
     * gcmParams=gcmPlayMode%3Dreal|   <br>
     *           gcmChannel%3DI| <br>
     *           gcmGameName%3Dgcm-example-game| <br>
     *           gcmCommonUIURL%3D%2Fgcm-tests%2Fgcm-example-commonui%2Fcommonui.html   <br>
     * The returned gcmParams variable is passed in this function to extract gcm parameters and its values.  <br>
     * All the extracted items will stored in array object as gcmParamsObject.
     * @param {string} gcmParams gcmParams value as string.
     * @return {Object} gcmParamsObject Object contains decoded gcm Parameters and its values. <br>
     *                                  the indices of values are removed 'gcm' prefix. <br>
     *                                  e.g. 'gcmGameName' will become 'gameName' as index in the returned object.
     */
    value: function getGCMParams(gcmParams) {
      var gcmParamsObject = {};
      if (gcmParams != null) {
        var extractedGCMParams = decodeURIComponent(gcmParams).split('|');
        var i = 0;
        for (i = 0; i < extractedGCMParams.length; i++) {
          var gcmParameter = extractedGCMParams[i].split('=');
          var gcmParameterKey = gcmParameter[0];
          gcmParameterKey = gcmParameterKey.replace('gcm', '');
          gcmParameterKey = gcmParameterKey.charAt(0).toLowerCase() + gcmParameterKey.slice(1);
          gcmParamsObject[gcmParameterKey] = gcmParameter[1];
        }
      }
      return gcmParamsObject;
    }
  }, {
    key: 'updateGCMParams',


    /**
    * This function updates the parameter value in gcmParams request parameter
    * @param {string} name request parameter name.
    * @param {string} newValue the new value for request parameter.
    * @param {string} url (this can be obtained from window.location.href).
    * @return {?string} The new url with updated request parameter.
    * This function will be called only when gcmParams request parameter needs
    * to be updated.
    * For example changing the gcmPlayMode from "demo" to "real.
    */
    value: function updateGCMParams(name, newValue, url) {
      var originalValue = '';

      var gcmParamsObject = new Array();
      var gcmParams = UrlUtil.getSearchParameterByName('gcmParams', url);
      if (gcmParams != null) {
        gcmParamsObject = UrlUtil.getGCMParams(gcmParams);
        var gcmParameterKey = name.replace('gcm', '');
        gcmParameterKey = gcmParameterKey.charAt(0).toLowerCase() + gcmParameterKey.slice(1);
        originalValue = gcmParamsObject[gcmParameterKey];
      }
      var newURL = url;
      if (originalValue) {
        newURL = url.replace(name + '%3D' + originalValue, name + '%3D' + newValue);
      }
      return newURL;
    }
  }, {
    key: 'getUrlParams',


    /**
    * This function is used to expose gcm param values to commonUI/Game. <br>
    * As soon as gcm.js is loaded during game loading phase, commonUI or Game can call this function to get gameplay information
    * such playMode, gameName, channel etc without having to wait for configReady() call from GCM.
    * CommonUI no longer needs to read this information from url passed by Game and Game no longer has to worry about passing
    * these params to CommonUI.
    * Currently this function provides all the parameters available in gcmParams object. This can be extended to included
    * any other url params.
    * gcmParams=gcmPlayMode%3Dreal|   <br>
    *           gcmChannel%3DI| <br>
    *           gcmGameName%3Dgcm-example-game| <br>
    *           gcmCommonUIURL%3D%2Fgcm-tests%2Fgcm-example-commonui%2Fcommonui.html   <br>
    * @return {Object} urlParamsObject Object contains params like playMode, gameName etc
    */
    value: function getUrlParams() {

      var urlParamsObject = {};
      var gcmParams = UrlUtil.getSearchParameterByName('gcmParams', window.parent.location.href);
      if (gcmParams) {
        urlParamsObject = UrlUtil.getGCMParams(gcmParams);
      } else {
        // In case we do not have gcmParams in game window url, we should search for the params in commonUI window url.
        // These data items are added to commonUI url from OpenBet gcmBridge.
        urlParamsObject['gameName'] = UrlUtil.getSearchParameterByName('gameName', window.location.search);
        urlParamsObject['playMode'] = UrlUtil.getSearchParameterByName('playMode', window.location.search);
        urlParamsObject['channel'] = UrlUtil.getSearchParameterByName('channel', window.location.search);
      }
      return urlParamsObject;
    }
  }, {
    key: 'getLaunchParamsObj',
    value: function getLaunchParamsObj(pgParams) {
      var gcmParamsObject = {};
      if (pgParams != null) {
        var extractedGCMParams = decodeURIComponent(pgParams).split('&');
        var i = 0;
        for (i = 0; i < extractedGCMParams.length; i++) {
          var gcmParameter = extractedGCMParams[i].split('=');
          var gcmParameterKey = gcmParameter[0];
          gcmParameterKey = gcmParameterKey.charAt(0).toLowerCase() + gcmParameterKey.slice(1);
          gcmParamsObject[gcmParameterKey] = gcmParameter[1];
        }
      }
      return gcmParamsObject;
    }
  }, {
    key: 'checkURIIsRelative',


    /**
     * checks if the uri paramater is a relative URI
     * This function protects us from
     * the potential security risk of rendering absolute url content that has been
     * specified as a request param
     * Note that not all relative URIs are allowed, but we do reject absolute URIs and
     * network-path references.
     * @param {string} url the URL to check.
     * @return {boolean} is this a relative url.
    */
    value: function checkURIIsRelative(url) {

      if (typeof url !== 'string') {
        throw new Error('UrlUtil.checkURIIsRelative: Invalid argument url - not a string');
      }

      // firstly we check that the URI doesn't start with either "<protocol>://" or
      // "//"
      // these would signify an absolute URI or a network-path reference, both of
      // which
      // would allow content from another domain.
      // anything else should be a URI requesting content from the same domain
      // note that www.google.com is not an absolute URI.  if you use 'www.google.com' as a link
      // from a page at http://www.openbet.com/games then the link will go to
      // http://www.openbet.com/games/www.google.com
      // also note that //www.google.com is a network-path reference.  If you use '//www.google.com'
      // as a link from a page at http://www.openbet.com/games then it will go to
      // http://www.google.com
      // more details can be found at http://tools.ietf.org/html/rfc3986

      if (/^([a-z0-9+.-]+):\/\//.test(url)) {
        return false;
      }

      if (/^\/\//.test(url)) {
        return false;
      }

      //we allow alphanumeric, "/", "_", "-", "." only
      //this is more restrictive than the full set of allowed URIs but we don't want to allow
      //features like request parameters etc. through at this stage
      return (/^[a-zA-Z0-9\/\.\-_]*$/.test(url)
      );
    }
  }, {
    key: 'getAllParams',
    value: function getAllParams(strUrl, isDesktop) {
      var keyPairs = [];
      var params = null;

      if (isDesktop) {
        //passed in from launcher, window.location.search (query string portion of the URL)
        params = strUrl.substring(1).split('&');
      } else {
        // passed in from game init() (full URL with domain and "?")
        params = strUrl.slice(strUrl.indexOf('?') + 1).split('&');
      }

      for (var i = params.length - 1; i >= 0; i--) {
        var nameValPair = params[i].split('=');
        keyPairs.push(nameValPair);
      };

      return keyPairs;
    }
  }]);

  return UrlUtil;
}();

/**
 * Create and export singleton
 */


var instance = new UrlUtil();
exports.default = instance;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function(global) {
  /**
   * Polyfill URLSearchParams
   *
   * Inspired from : http://github.com/WebReflection/url-search-params/blob/master/src/url-search-params.js
   */

  var checkIfIteratorIsSupported = function() {
    try {
      return !!Symbol.iterator;
    } catch(error) {
      return false;
    }
  };


  var iteratorSupported = checkIfIteratorIsSupported();

  var createIterator = function(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return { done: value === void 0, value: value };
      }
    };

    if(iteratorSupported) {
      iterator[Symbol.iterator] = function() {
        return iterator;
      };
    }

    return iterator;
  };

  /**
   * Search param name and values should be encoded according to http://url.spec.whatwg.org/#urlencoded-serializing
   * encodeURIComponent() produces the same result except encoding spaces as `%20` instead of `+`.
   */
  var serializeParam = function(value) {
    return encodeURIComponent(value).replace(/%20/g, '+');
  };

  var deserializeParam = function(value) {
    return decodeURIComponent(value).replace(/\+/g, ' ');
  };

  var polyfillURLSearchParams= function() {

    var URLSearchParams = function(searchString) {
      Object.defineProperty(this, '_entries', { value: {} });

      if(typeof searchString === 'string') {
        if(searchString !== '') {
          searchString = searchString.replace(/^\?/, '');
          var attributes = searchString.split('&');
          var attribute;
          for(var i = 0; i < attributes.length; i++) {
            attribute = attributes[i].split('=');
            this.append(
              deserializeParam(attribute[0]),
              (attribute.length > 1) ? deserializeParam(attribute[1]) : ''
            );
          }
        }
      } else if(searchString instanceof URLSearchParams) {
        var _this = this;
        searchString.forEach(function(value, name) {
          _this.append(value, name);
        });
      }
    };

    var proto = URLSearchParams.prototype;

    proto.append = function(name, value) {
      if(name in this._entries) {
        this._entries[name].push(value.toString());
      } else {
        this._entries[name] = [value.toString()];
      }
    };

    proto.delete = function(name) {
      delete this._entries[name];
    };

    proto.get = function(name) {
      return (name in this._entries) ? this._entries[name][0] : null;
    };

    proto.getAll = function(name) {
      return (name in this._entries) ? this._entries[name].slice(0) : [];
    };

    proto.has = function(name) {
      return (name in this._entries);
    };

    proto.set = function(name, value) {
      this._entries[name] = [value.toString()];
    };

    proto.forEach = function(callback, thisArg) {
      var entries;
      for(var name in this._entries) {
        if(this._entries.hasOwnProperty(name)) {
          entries = this._entries[name];
          for(var i = 0; i < entries.length; i++) {
            callback.call(thisArg, entries[i], name, this);
          }
        }
      }
    };

    proto.keys = function() {
      var items = [];
      this.forEach(function(value, name) { items.push(name); });
      return createIterator(items);
    };

    proto.values = function() {
      var items = [];
      this.forEach(function(value) { items.push(value); });
      return createIterator(items);
    };

    proto.entries = function() {
      var items = [];
      this.forEach(function(value, name) { items.push([name, value]); });
      return createIterator(items);
    };

    if(iteratorSupported) {
      proto[Symbol.iterator] = proto.entries;
    }

    proto.toString = function() {
      var searchString = '';
      this.forEach(function(value, name) {
        if(searchString.length > 0) searchString+= '&';
        searchString += serializeParam(name) + '=' + serializeParam(value);
      });
      return searchString;
    };

    global.URLSearchParams = URLSearchParams;
  };

  if(!('URLSearchParams' in global) || (new URLSearchParams('?a=1').toString() !== 'a=1')) {
    polyfillURLSearchParams();
  }

  // HTMLAnchorElement

})(
  (typeof global !== 'undefined') ? global
    : ((typeof window !== 'undefined') ? window
    : ((typeof self !== 'undefined') ? self : this))
);

(function(global) {
  /**
   * Polyfill URL
   *
   * Inspired from : http://github.com/arv/DOM-URL-Polyfill/blob/master/src/url.js
   */

  var checkIfURLIsSupported = function() {
    try {
      var u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      return (u.href === 'http://a/c%20d') && u.searchParams;
    } catch(e) {
      return false;
    }
  };


  var polyfillURL = function() {
    var _URL = global.URL;

    var URL = function(url, base) {
      if(typeof url !== 'string') url = String(url);

      var doc = document.implementation.createHTMLDocument('');
      window.doc = doc;
      if(base) {
        var baseElement = doc.createElement('base');
        baseElement.href = base;
        doc.head.appendChild(baseElement);
      }

      var anchorElement = doc.createElement('a');
      anchorElement.href = url;
      doc.body.appendChild(anchorElement);
      anchorElement.href = anchorElement.href; // force href to refresh

      if(anchorElement.protocol === ':' || !/:/.test(anchorElement.href)) {
        throw new TypeError('Invalid URL');
      }

      Object.defineProperty(this, '_anchorElement', {
        value: anchorElement
      });
    };

    var proto = URL.prototype;

    var linkURLWithAnchorAttribute = function(attributeName) {
      Object.defineProperty(proto, attributeName, {
        get: function() {
          return this._anchorElement[attributeName];
        },
        set: function(value) {
          this._anchorElement[attributeName] = value;
        },
        enumerable: true
      });
    };

    ['hash', 'host', 'hostname', 'port', 'protocol', 'search']
    .forEach(function(attributeName) {
      linkURLWithAnchorAttribute(attributeName);
    });

    Object.defineProperties(proto, {

      'toString': {
        get: function() {
          var _this = this;
          return function() {
            return _this.href;
          };
        }
      },

      'href' : {
        get: function() {
          return this._anchorElement.href.replace(/\?$/,'');
        },
        set: function(value) {
          this._anchorElement.href = value;
        },
        enumerable: true
      },

      'pathname' : {
        get: function() {
          return this._anchorElement.pathname.replace(/(^\/?)/,'/');
        },
        set: function(value) {
          this._anchorElement.pathname = value;
        },
        enumerable: true
      },

      'origin': {
        get: function() {
          // get expected port from protocol
          var expectedPort = {'http:': 80, 'http:': 443, 'ftp:': 21}[this._anchorElement.protocol];
          // add port to origin if, expected port is different than actual port
          // and it is not empty f.e http://foo:8080
          // 8080 != 80 && 8080 != ''
          var addPortToOrigin = this._anchorElement.port != expectedPort &&
            this._anchorElement.port !== ''

          return this._anchorElement.protocol +
            '//' +
            this._anchorElement.hostname +
            (addPortToOrigin ? (':' + this._anchorElement.port) : '');
        },
        enumerable: true
      },

      'password': { // TODO
        get: function() {
          return '';
        },
        set: function(value) {
        },
        enumerable: true
      },

      'username': { // TODO
        get: function() {
          return '';
        },
        set: function(value) {
        },
        enumerable: true
      },

      'searchParams': {
        get: function() {
          var searchParams = new URLSearchParams(this.search);
          var _this = this;
          ['append', 'delete', 'set'].forEach(function(methodName) {
            var method = searchParams[methodName];
            searchParams[methodName] = function() {
              method.apply(searchParams, arguments);
              _this.search = searchParams.toString();
            };
          });
          return searchParams;
        },
        enumerable: true
      }
    });

    URL.createObjectURL = function(blob) {
      return _URL.createObjectURL.apply(_URL, arguments);
    };

    URL.revokeObjectURL = function(url) {
      return _URL.revokeObjectURL.apply(_URL, arguments);
    };

    global.URL = URL;

  };

  if(!checkIfURLIsSupported()) {
    polyfillURL();
  }

  if((global.location !== void 0) && !('origin' in global.location)) {
    var getOrigin = function() {
      return global.location.protocol + '//' + global.location.hostname + (global.location.port ? (':' + global.location.port) : '');
    };

    try {
      Object.defineProperty(global.location, 'origin', {
        get: getOrigin,
        enumerable: true
      });
    } catch(e) {
      setInterval(function() {
        global.location.origin = getOrigin();
      }, 100);
    }
  }

})(
  (typeof global !== 'undefined') ? global
    : ((typeof window !== 'undefined') ? window
    : ((typeof self !== 'undefined') ? self : this))
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 4 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })
/******/ ]);


// WEBPACK FOOTER //
// src/js/dist/gcmLauncher.min.js